
# 胜者树和败者树  

**被败者树中的并查集弄晕了(但是明明可以不用并查集),使用文字总结下** 


### 胜者树的实现代码  

```C++
#include <stdio.h>
#define K 10
#define MAX 65535
int leaves[K+1];
int successTree[K];

/* 对于单个内部节点进行调整 */
void adjust(int i)
{
    int m,n;
    if(2 * i < K)               /* 获取它的左孩子结点 */
        m = successTree[2 * i];
    else
        m = 2 * i - K + 1;
    if(2*i+1<K)                 /* 获取它的右孩子节点 */
        n = successTree[2*i+1];
    else
        n = 2 * i + - K + 2;
    successTree[i] = leaves[m] > leaves[n] ? n : m; /* 进行胜负判定 */
}
/* 初始化叶子节点并对内部节点进行类似于堆的调整 */
void initTree()
{
    for(int i=1;i<K+1;i++)
        scanf("%d", &leaves[i]);
    for(int i=K-1;i>0;i--)
        adjust(i);
}
/* 自下而上对胜者树进行调整 */
void adjustToRoot(int i)
{
    int parent = (i + K - 1) / 2; /* 对从当前节点到根节点路径上的所有
                                   * 节点进行调整 */
    while(parent>0)
    {
        adjust(parent);
        parent = parent / 2;
    }
}

int main()
{
    freopen("in","r",stdin);
    initTree();
    for(int i=1;i<K+1;i++)      /* 每次用最大值替换掉冠军节点，并对树
                                 * 进行调整,最终得到升序排序的序列 */
    {
        printf("%d ", leaves[successTree[1]]);
        leaves[successTree[1]]=MAX;
        adjustToRoot(successTree[1]);
    }
    return 0;
}
```

### 败者树的实现代码  

```C++

int loserTree[K];               /* 存储中间节点值，下标0处存储冠军节点 */
int leaves[K+1];                /* 从下标1开始存储叶子节点值，下标0处存储一个最小值节点 */

void adjust(int i)
{
    int parent=(i+K-1)/2;      /* 求出父节点的下标 */
    while(parent>0)
    {
        if(leaves[i]>leaves[loserTree[parent]])
        {
            int temp=loserTree[parent];
            loserTree[parent]=i;
            /* i指向的是优胜者 */
            i= temp;
        }
        parent = parent / 2;
    }
    loserTree[0]=i;
}

void initLoserTree()
{
    int i;
    for(i=1;i<K+1;i++)
        scanf("%d",&leaves[i]);
    leaves[0]=MIN;
    for(int i=0;i<K;i++)
        loserTree[i]=0;
    for(int i=K;i>0;i--)
        adjust(i);
}
```
